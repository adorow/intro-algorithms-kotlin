Chapter 13. Red-Black Trees
===========================

### Properties of red-black trees

Red-black trees are one of many search-tree schemes that are "balanced" in order to guarantee that basic dynamic-set operations take _O_(lg _n_) time in the worst case.

A **red-black tree** is a binary search tree that carries one extra property: its **color**, which can be either _RED_ or _BLACK_.
By constraining the node colors on any simple path from the root to a leaf, red-black trees ensure that no such path is more than twice as long as any other, so that the tree is _approximately balanced_.

A red-black tree satisfies the following **red-black tree properties**:

1. Every node is either red or black.
2. The root is black.
3. Every leaf (_NIL_) is black.
4. If a node is red, then both its children are black.
5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.

We call the number of black nodes on any simple path from, but not including, a node _x_ down to a leaf the **black-height** of the node, denoted bh(_x_). 
We define the black-height of a red-black tree to be the black-height of its root.

A leaf is usually represented by _NIL_. 
In code the expression _T_._nil_ is used, which means that the same _nil_ structure is used to represent every leaf.

### Rotations

The search-tree operations _TREE-INSERT_ and _TREE-DELETE_, when run on a red-black tree with _n_ keys, take _O_(lg _n_) time.
Because they modify the tree, the result may violate the red-black tree properties.
To restore these properties, we must change the colors of some nodes in the tree, and also some pointers.

We change the pointer structure via **rotation**, which is a local operation that preserves the binary-search-tree property.
When we do a left rotation on a node _x_, we assume that its right child _y_ is not _T_._nil_; _x_ may be any node in the tree whose right child is not _T_._nil_. 
The left rotation "pivots" around the link from _x_ to _y_. 
It makes _y_ the new root of the subtree, with _x_ as _y_'s left child and _y_'s left child as _x_'s right child.

The pseudocode for _LEFT-ROTATE_ assumes that _x_._right_ ≠ _T_._nil_ and that the root's parent is _T_._nil_.

**Pseudocode**:
>Left-Rotate(_T_, _x_)  
&nbsp;&nbsp;&nbsp;&nbsp;    _y_ = _x_._right_           // set _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    _x_._right_ = _y_._left_    // turn _y_'s left subtree into _x_'s right subtree  
&nbsp;&nbsp;&nbsp;&nbsp;    **if** _y_._left_ ≠ _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         _y_._left_._p_ = _x_  
&nbsp;&nbsp;&nbsp;&nbsp;    _y_._p_ = _x_._p_           // link _x_'s parent to _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    **if** _x_._p_ = _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         _T_._root_ = _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    **elseif** _x_ = _x_._p_._left_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         _x_._p_._left_ = _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    **else** _x_._p_._right_ = _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    _y_._left_ = _x_            // put _x_ on _y_'s left  
&nbsp;&nbsp;&nbsp;&nbsp;    _x_._p_ = _y_  

**In Kotlin**: [Implementation](../src/main/kotlin/chapter13/RedBlackTree.kt) and [Tests](../src/test/kotlin/chapter13/RedBlackTreeTest.kt)

The code for _RIGHT-ROTATE_ is symmetric to _LEFT-ROTATE_.
Both _LEFT-ROTATE_ and _RIGHT-ROTATE_ run in _O_(1) time.
Only pointers are changed by a rotation, all other attributes remain the same.

### Insertion

We can insert a node into a _n_-node red-black tree in _O_(lg _n_) time.
To do so we need a slightly modified version of the _TREE-INSERT_ [procedure](3.12.md) to insert node _z_ into the tree and then color it _red_.
Then we call an auxiliary procedure _RB-INSERT-FIXUP_ to recolor nodes and perform rotations.

**Pseudocode**:
>RB-Insert(_T_, _z_)  
&nbsp;&nbsp;&nbsp;&nbsp;    _y_ = _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;    _x_ = _T_._root_  
&nbsp;&nbsp;&nbsp;&nbsp;    **while** _x_ ≠ _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        _y_ = _x_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        **if** _z_._key_ < _x_._key_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            _x_ = _x_._left_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        **else** _x_ = _x_._right_  
&nbsp;&nbsp;&nbsp;&nbsp;    _z_._p_ = _y_  
&nbsp;&nbsp;&nbsp;&nbsp;    **if** _y_ == _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        _T_._root_ = _z_  
&nbsp;&nbsp;&nbsp;&nbsp;    **elseif** _z_._key_ < _y_._key_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        _y_._left_ = _z_  
&nbsp;&nbsp;&nbsp;&nbsp;    **else** _y_._right_ = _z_  
&nbsp;&nbsp;&nbsp;&nbsp;    _z_._left_ = _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;    _z_._right_ = _T_._nil_  
&nbsp;&nbsp;&nbsp;&nbsp;    _z_._color_ = RED  
&nbsp;&nbsp;&nbsp;&nbsp;    RB-INSERT-FIXUP(_T_, _z_)  

**In Kotlin**: [Implementation](../src/main/kotlin/chapter13/RedBlackTree.kt) and [Tests](../src/test/kotlin/chapter13/RedBlackTreeTest.kt)

The procedures _TREE-INSERT_ and _RB-INSERT_ differ in four ways:
* NIL in _TREE-INSERT_ is replaced by _T_._nil_
* _z_._left_ and _z_._right_ are set to _T_._nil_ at the end, in order to maintain a proper tree structure
* we color _z_ red
* because coloring red may cause a violation of one of the red-black properties, we call _RB-INSERT-FIXUP_(_T_, _z_) to restore the red-black tree properties

**Pseudocode**:
>RB-Insert-Fixup(_T_, _z_)  
&nbsp;&nbsp;&nbsp;&nbsp;    **while** _z_._p_._color_ == RED  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        **if** _z_._p_ == _z_._p_._p_._left_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            _y_ = _z_._p_._p_._right_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            **if** _y_._color_ == RED  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _z_._p_._color_ = BLACK // case 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _y_._color_ = BLACK // case 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _z_._p_._p_._color_ = RED // case 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _z_ = _z_._p_._p_ // case 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            **elseif** _z_ = _z_._p_._right_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    _z_ = _z_._p_ // case 2  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    LEFT-ROTATE(_T_, _z_) // case 2  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _z_._p_._color_ = BLACK // case 3  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                _z_._p_._p_._color_ = RED // case 3  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                RIGHT-ROTATE(_T_, _z_._p_._p_) // case 3  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            **else** (same as **then** clause with "right" and "left" exchanged)  
&nbsp;&nbsp;&nbsp;&nbsp;    _T_._root_._color_ = BLACK  

**In Kotlin**: [Implementation](../src/main/kotlin/chapter13/RedBlackTree.kt) and [Tests](../src/test/kotlin/chapter13/RedBlackTreeTest.kt)

Which of the red-black properties might be violated upon the call to RB-INSERT-FIXUP? 
Property 1 certainly continues to hold, as does property 3, since both children of the newly inserted red node are the sentinel _T_._nil_. 
Property 5, which says that the number of black nodes is the same on every simple path from a given node, is satisfied as well, because node _z_ replaces the (black) sentinel, and node _z_ is red with sentinel children. 
Thus, the only properties that might be violated are property 2, which requires the root to be black, and property 4, which says that a red node cannot have a red child. 
Both possible violations are due to _z_ being colored red. 
Property 2 is violated if _z_ is the root, and property 4 is violated if _z_'s parent is red. 

The **while** loop maintains the following three-part invariant at the start of each iteration of the loop:

1. Node _z_ is red.
2. If _z_._p_ is the root, then _z_._p_ is black.
3. If the tree violates any of the red-black properties, then it violates at most one of them, and the violation is of either property 2 or property 4. If the tree violates property 2, it is because _z_ is the root and is red. If the tree violates property 4, it is because both _z_ and _z_._p_ are red.

The third part, which deals with the violations of the red-black properties, is central to understanding that _RB-INSERT-FIXUP_ restores the red-black properties.

