Chapter 7. Quicksort
====================

This chapter introduces the Quicksort algorithm.
Although having a worst-case running time of _θ_(_n<sup>2</sup>_), it is still one of the best practical choices for sorting, as it is remarkably efficient on the average. 
Its expected running time is  _θ_(_n_ lg _n_), and the constant factors hidden in it are quite small. 
It also has the advantage of sorting in place.

## Quicksort

Like merge sort, quicksort applies a divide-and-conquer strategy.
Below is the three-step divide-and-conquer process for sorting with quicksort:

**Divide**: Partition (rearrange) the array _A_\[_p_.._r_] into two (possibly empty) subarrays _A_\[_p_.._q_ - 1] and _A_\[_q_ + 1.._r_] such that each element of _A_\[_p_.._q_ - 1] is less than or equal to _A_\[_q_], which is, in turn, less than or equal to each element of _A_\[_q_ + 1.._r_].
Compute the index _q_ as part of this partitioning procedure.

**Conquer**: Sort the two subarrays _A_\[_p_.._q_ - 1] and _A_\[_q + 1_.._r_] by recursive calls to quicksort.

**Combine**: Because the subarrays are already sorted, no work is needed to combine them: the entire array _A_\[_p_.._r_] is now sorted.  

As for the algorithm:

**Input**: A sequence of _n_ numbers \<_a_<sub>1</sub>, _a_<sub>2</sub>, ..., _a_<sub>n</sub>\>.

**Output**: A permutation (reordering) \<_a'_<sub>1</sub>, _a'_<sub>2</sub>, ..., _a'_<sub>_n_</sub>\> of the input sequence such that _a'_<sub>1</sub> <= _a'_<sub>2</sub> <= ... <= _a'_<sub>_n_</sub>.


**Pseudocode**:
>Quicksort(_A_, _p_, _r_)  
&nbsp;&nbsp;&nbsp;&nbsp;    **if** _p_ < _r_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        _q_ = Partition(_A_, _p_, _r_)  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Quicksort(_A_, _p_, _q_ -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Quicksort(_A_, _q_ + 1, _r_)  

>Partition(_A_, _p_, _r_)  
&nbsp;&nbsp;&nbsp;&nbsp;    _x_ = _A_\[_r_]  
&nbsp;&nbsp;&nbsp;&nbsp;    _i_ = _p_ - 1  
&nbsp;&nbsp;&nbsp;&nbsp;    **for** _j_ = _p_ **to** _r_ - 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        **if** _A_\[_j_] ≤ _x_  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            _i_ = _i_ + 1  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            exchange _A_\[_i_] with _A_\[_j_]  
&nbsp;&nbsp;&nbsp;&nbsp;    exchange _A_\[_i_ + 1] with _A_\[_r_]  
&nbsp;&nbsp;&nbsp;&nbsp;    **return** _i_ + 1  


**In Kotlin**: [Implementation](../src/main/kotlin/chapter07/Quicksort.kt) and [Tests](../src/test/kotlin/chapter07/QuicksortTest.kt).


